// insert-missing-v1-opportunities.js
// Inserts the actioned V1 opportunities that weren't generated by V2 triggers
// These are opportunities the staff already worked on - we need to track their value

import fs from 'fs';
import { parse } from 'csv-parse/sync';
import pg from 'pg';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';

dotenv.config();

const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

async function insertMissing(email, csvPath) {
  console.log(`\nüîÑ Inserting missing V1 actioned opportunities for: ${email}`);
  
  // Get pharmacy ID and patients
  const userResult = await pool.query('SELECT pharmacy_id FROM users WHERE email = $1', [email]);
  if (userResult.rows.length === 0) {
    console.error('‚ùå User not found:', email);
    process.exit(1);
  }
  const pharmacyId = userResult.rows[0].pharmacy_id;
  console.log(`üìç Pharmacy ID: ${pharmacyId}`);

  // Get all patients
  const patientsResult = await pool.query(`
    SELECT patient_id, first_name, last_name, primary_insurance_bin, primary_insurance_group
    FROM patients WHERE pharmacy_id = $1
  `, [pharmacyId]);
  
  // Build patient lookup
  const patientMap = new Map();
  for (const p of patientsResult.rows) {
    const firstName = (p.first_name || '').toUpperCase().slice(0, 3);
    const lastName = (p.last_name || '').toUpperCase().slice(0, 3);
    const key = `${lastName},${firstName}`;
    patientMap.set(key, p);
  }

  // Get existing V2 opportunities to avoid duplicates
  const existingOpps = await pool.query(`
    SELECT o.opportunity_id, o.recommended_drug_name, p.first_name, p.last_name
    FROM opportunities o
    JOIN patients p ON p.patient_id = o.patient_id
    WHERE o.pharmacy_id = $1
  `, [pharmacyId]);
  
  const existingSet = new Set();
  for (const opp of existingOpps.rows) {
    const firstName = (opp.first_name || '').toUpperCase().slice(0, 3);
    const lastName = (opp.last_name || '').toUpperCase().slice(0, 3);
    const recDrug = (opp.recommended_drug_name || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 20);
    existingSet.add(`${lastName},${firstName}|${recDrug}`);
  }

  // Read V1 CSV
  const csvContent = fs.readFileSync(csvPath, 'utf-8');
  const records = parse(csvContent, {
    columns: true,
    skip_empty_lines: true,
    relax_quotes: true,
    relax_column_count: true,
  });

  let inserted = 0;
  let skipped = 0;
  let patientNotFound = 0;

  for (const row of records) {
    const v1Status = (row.Status || '').trim();
    
    // Only process opportunities with real statuses (not blank or Not Submitted)
    if (!v1Status || v1Status === 'Not Submitted') {
      continue;
    }

    // Normalize status
    const status = v1Status === "Didn't work" ? "Didn't Work" : v1Status;

    const patientMasked = (row.Patient_Masked || '').toUpperCase().trim();
    const recDrug = (row.Recommended_Drug || '');
    const recDrugNorm = recDrug.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 20);
    const key = `${patientMasked}|${recDrugNorm}`;

    // Skip if already exists in V2
    if (existingSet.has(key)) {
      skipped++;
      continue;
    }

    // Find patient
    const patient = patientMap.get(patientMasked);
    if (!patient) {
      console.log(`  ‚ö†Ô∏è  Patient not found: ${patientMasked}`);
      patientNotFound++;
      continue;
    }

    // Parse values
    const annualValue = parseFloat((row['Annual Value'] || '0').replace(/[$,]/g, '')) || 0;
    const monthlyValue = annualValue / 12;

    try {
      await pool.query(`
        INSERT INTO opportunities (
          opportunity_id, pharmacy_id, patient_id, opportunity_type,
          current_drug_name, recommended_drug_name,
          potential_margin_gain, annual_margin_gain,
          clinical_rationale, clinical_priority, status,
          created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())
      `, [
        uuidv4(),
        pharmacyId,
        patient.patient_id,
        'therapeutic_interchange',  // Valid type from constraint
        row.Current_Drug || 'Unknown',
        recDrug,
        monthlyValue,
        annualValue,
        `${row.Trigger_Reason || ''}\n\nAction: ${row.Action || ''}\n\n[Imported from V1 - Original Status: ${status}]`,
        'medium',
        status,
      ]);
      
      console.log(`  ‚úÖ Inserted: ${patientMasked} ‚Üí ${recDrug.slice(0, 30)} (${status}) $${annualValue.toFixed(2)}`);
      inserted++;
      existingSet.add(key); // Prevent duplicates within this run
    } catch (error) {
      console.error(`  ‚ùå Error inserting ${patientMasked}: ${error.message}`);
    }
  }

  console.log(`\nüìà Import Summary:`);
  console.log(`   Inserted: ${inserted}`);
  console.log(`   Skipped (already in V2): ${skipped}`);
  console.log(`   Patient not found: ${patientNotFound}`);

  await pool.end();
  console.log('\n‚úÖ Import complete!');
}

// Main
const args = process.argv.slice(2);
if (args.length < 2) {
  console.log('Usage: node insert-missing-v1-opportunities.js <email> <v1-csv-path>');
  process.exit(1);
}

insertMissing(args[0], args[1]).catch(err => {
  console.error('Import failed:', err);
  process.exit(1);
});
